
<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>å¿ƒåŠ¨æ—¶åˆ» - Blue</title>
  <link rel="icon" href="img/logo/4.gif" type="image/gif">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Not0+Sans+SC:wght@300;400;500;700&display=swap">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body, html {
      height: 100%;
      overflow: hidden;
      background: #fff;
      font-family: 'Noto Sans SC', 'Microsoft YaHei', sans-serif;
    }
    
    /* çˆ±å¿ƒåŠ¨ç”»å®¹å™¨ */
    .heart-container {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
      overflow: hidden;
      display: flex;
      justify-content: center;
      align-items: center;
      transition: opacity 1.5s ease;
      z-index: 2;
    }
    
    /* ä¾¿ç­¾å¢™å®¹å™¨ */
    .sticky-container {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-image: linear-gradient(0deg, #eee 1px, transparent 0),
                        linear-gradient(90deg, #eee 1px, transparent 0);
      background-size: 30px 30px;
      overflow: hidden;
      opacity: 0;
      transition: opacity 1.5s ease;
      z-index: 1;
    }
    
    /* èƒŒæ™¯åŠ¨æ€ç²’å­ */
    .particles {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 1;
    }
    
    .particle {
      position: absolute;
      width: 4px;
      height: 4px;
      background: rgba(255, 255, 255, 0.7);
      border-radius: 50%;
      pointer-events: none;
      box-shadow: 0 0 10px rgba(255, 255, 255, 0.8);
    }
    
    .header {
      position: absolute;
      top: 42px;
      left: 0;
      width: 100%;
      text-align: center;
      z-index: 5;
      opacity: 0;
      animation: fadeIn 2s ease 0.5s forwards;
    }
    
    .header h1 {
      font-size: 2.5rem;
      font-weight: 300;
      color: #5a6c8d;
      margin-bottom: 10px;
      letter-spacing: 2px;
      text-shadow: 0 2px 10px rgba(0, 0, 0, 0.05);
    }
    
    .header p {
      font-size: 1.1rem;
      color: #7d8fb3;
      font-weight: 300;
      letter-spacing: 1px;
    }
    
    .floating-container {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 10;
    }
    
    .floating-text {
      position: absolute;
      padding: 12px 24px;
      border-radius: 30px;
      white-space: nowrap;
      text-align: center;
      color: #333;
      box-shadow: 
        0 8px 25px rgba(0, 0, 0, 0.1),
        inset 0 1px 0 rgba(255, 255, 255, 0.9),
        inset 0 -1px 0 rgba(0, 0, 0, 0.05);
      font-weight: 500;
      letter-spacing: 1px;
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.7);
      opacity: 0;
      transform: scale(0.9);
      animation: gatherCenter 7s ease-in-out forwards;
      transition: all 0.4s ease;
    }
    
    .heart-text {
      animation: heartGather 5s ease-out forwards;
      z-index: 20;
      box-shadow: 
        0 10px 30px rgba(0, 0, 0, 0.15),
        inset 0 1px 0 rgba(255, 255, 255, 0.9),
        inset 0 -1px 0 rgba(0, 0, 0, 0.05);
    }
    
    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(-20px); }
      to { opacity: 1; transform: translateY(0); }
    }
    
    @keyframes gatherCenter {
      0% {
        opacity: 0.9;
        transform: scale(0.9);
      }
      30% {
        opacity: 1;
        transform: scale(1.05);
      }
      100% {
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%) scale(1.1);
        opacity: 0;
      }
    }
    
    @keyframes heartGather {
      0% {
        opacity: 0;
        transform: scale(0.5) rotate(0deg);
      }
      50% {
        opacity: 0.8;
        transform: scale(0.95) rotate(3deg);
      }
      100% {
        opacity: 1;
        transform: scale(1) rotate(0deg);
      }
    }
    
    .sparkle {
      position: absolute;
      width: 4px;
      height: 4px;
      background: white;
      border-radius: 50%;
      pointer-events: none;
      opacity: 0;
      box-shadow: 0 0 6px 2px rgba(255, 255, 255, 0.8);
      z-index: 5;
    }
    
    .pulse {
      animation: pulse 2s infinite;
    }
    
    @keyframes pulse {
      0% { transform: scale(1); opacity: 0.8; }
      50% { transform: scale(1.05); opacity: 1; }
      100% { transform: scale(1); opacity: 0.8; }
    }
    
    .footer {
      position: absolute;
      bottom: 20px;
      left: 0;
      width: 100%;
      text-align: center;
      color: rgba(90, 108, 141, 0.6);
      font-size: 0.9rem;
      z-index: 5;
      opacity: 0;
      animation: fadeIn 2s ease 1.5s forwards;
    }
    
    /* åŠ¨æ€èƒŒæ™¯ */
    .dynamic-bg {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 0;
      opacity: 0.4;
    }
    
    .bg-circle {
      position: absolute;
      border-radius: 50%;
      filter: blur(40px);
      opacity: 0.5;
      animation: float 15s infinite ease-in-out;
    }
    
    @keyframes float {
      0%, 100% { transform: translate(0, 0) scale(1); }
      25% { transform: translate(20px, 20px) scale(1.1); }
      50% { transform: translate(-15px, 10px) scale(0.9); }
      75% { transform: translate(10px, -15px) scale(1.05); }
    }
    
    /* ç‰¹æ®Šæ–‡å­—æ•ˆæœ */
    .special-text {
      background: linear-gradient(135deg, #ff9a9e, #fecfef) !important;
      color: white !important;
      font-weight: 700 !important;
      box-shadow: 0 10px 30px rgba(255, 154, 158, 0.3) !important;
      border: 1px solid rgba(255, 255, 255, 0.8) !important;
    }
    
    /* GOæŒ‰é’®æ ·å¼ - é‡æ–°è®¾è®¡ */
    .go-button {
      position: absolute;
      top:   90%; /* æ”¾åœ¨çˆ±å¿ƒä¸‹æ–¹ */
      left: 53%;
      transform: translate(-50%, -50%) scale(0) rotate(-10deg);
      padding: 16px 50px;
      background: linear-gradient(135deg, #ff9a9e, #fecfef);
      color: white;
      border: none;
      border-radius: 50px;
      font-size: 28px;
      font-weight: 700;
      letter-spacing: 3px;
      cursor: pointer;
      box-shadow: 
        0 10px 30px rgba(255, 154, 158, 0.4),
        0 0 0 4px rgba(255, 255, 255, 0.8),
        0 0 20px rgba(255, 255, 255, 0.6);
      transition: all 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);
      z-index: 200;
      pointer-events: auto;
      text-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
      overflow: hidden;
    }
    
    .go-button::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.4), transparent);
      transition: left 0.8s ease;
    }
    
    .go-button:hover::before {
      left: 100%;
    }
    
    .go-button.show {
      transform: translate(-50%, -50%) scale(1) rotate(0deg);
      animation: buttonPulse 2s infinite;
    }
    
    .go-button:hover {
      transform: translate(-50%, -50%) scale(1.1);
      box-shadow: 
        0 15px 40px rgba(255, 154, 158, 0.6),
        0 0 0 6px rgba(255, 255, 255, 0.9),
        0 0 30px rgba(255, 255, 255, 0.8);
    }
    
    @keyframes buttonPulse {
      0%, 100% { 
        box-shadow: 
          0 10px 30px rgba(255, 154, 158, 0.4),
          0 0 0 4px rgba(255, 255, 255, 0.8),
          0 0 20px rgba(255, 255, 255, 0.6);
      }
      50% { 
        box-shadow: 
          0 10px 40px rgba(255, 154, 158, 0.6),
          0 0 0 6px rgba(255, 255, 255, 0.9),
          0 0 30px rgba(255, 255, 255, 0.8);
      }
    }
    
    /* éŸ³ä¹æ§åˆ¶æŒ‰é’® */
    .music-control {
      position: absolute;
      top: 30px;
      right: 30px;
      width: 50px;
      height: 50px;
      background: rgba(255, 255, 255, 0.8);
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      z-index: 100;
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
      transition: all 0.3s ease;
      backdrop-filter: blur(5px);
      border: 1px solid rgba(255, 255, 255, 0.5);
    }
    
    .music-control:hover {
      transform: scale(1.1);
      background: rgba(255, 255, 255, 0.9);
      box-shadow: 0 6px 20px rgba(0, 0, 0, 0.15);
    }
    
    .music-control .icon {
      width: 24px;
      height: 24px;
      position: relative;
    }
    
    .music-control .play-icon,
    .music-control .pause-icon {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      transition: opacity 0.3s ease;
    }
    
    .music-control .play-icon {
      opacity: 0;
    }
    
    .music-control .pause-icon {
      opacity: 1;
    }
    
    .music-control.playing .play-icon {
      opacity: 0;
    }
    
    .music-control.playing .pause-icon {
      opacity: 1;
    }
    
    .music-control.paused .play-icon {
      opacity: 1;
    }
    
    .music-control.paused .pause-icon {
      opacity: 0;
    }
    
    /* éŸ³ä¹æ³¢çº¹æ•ˆæœ */
    .music-waves {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      border-radius: 50%;
      opacity: 0;
      pointer-events: none;
    }
    
    .music-control.playing .music-waves {
      animation: musicWave 1.5s infinite linear;
    }
    
    @keyframes musicWave {
      0% {
        box-shadow: 0 0 0 0 rgba(255, 154, 158, 0.4);
        opacity: 1;
      }
      70% {
        box-shadow: 0 0 0 15px rgba(255, 154, 158, 0);
        opacity: 0.7;
      }
      100% {
        box-shadow: 0 0 0 25px rgba(255, 154, 158, 0);
        opacity: 0;
      }
    }
    
    /* éŸ³ä¹åŠ è½½æç¤º */
    .music-loading {
      position: absolute;
      top: 30px;
      right: 90px;
      background: rgba(255, 255, 255, 0.8);
      padding: 8px 12px;
      border-radius: 20px;
      font-size: 12px;
      color: #5a6c8d;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
      backdrop-filter: blur(5px);
      border: 1px solid rgba(255, 255, 255, 0.5);
      opacity: 0;
      transition: opacity 0.3s ease;
      pointer-events: none;
    }
    
    .music-loading.show {
      opacity: 1;
    }
    
    /* ä¾¿ç­¾å¡ç‰‡æ ·å¼ */
    .card {
      position: absolute;
      width: 220px;
      border-radius: 12px;
      box-shadow: 0 16px 35px rgba(0, 0, 0, 0.2);
      background: #fff;
      border: 1px solid rgba(0, 0, 0, 0.08);
      overflow: hidden;
      opacity: 0;
      transform-origin: center;
      transition: transform 0.35s ease, opacity 0.35s ease, left 0.35s ease,
        top 0.35s ease, width 0.35s ease, height 0.35s ease,
        border-radius 0.35s ease;
    }
    
    .card.dragging {
      transition: none;
      box-shadow: 0 22px 45px rgba(0, 0, 0, 0.35);
    }
    
    .card.maximized {
      box-shadow: 0 28px 60px rgba(0, 0, 0, 0.4);
    }
    
    .card-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 10px 12px;
      background: rgba(255, 255, 255, 0.7);
      cursor: grab;
      user-select: none;
      touch-action: pan-y;
    }
    
    .card-header.dragging {
      cursor: grabbing;
    }
    
    .window-controls {
      display: flex;
      align-items: center;
      gap: 6px;
    }
    
    .window-controls .control {
      position: relative;
      width: 12px;
      height: 12px;
      border-radius: 50%;
      border: 1px solid rgba(0, 0, 0, 0.08);
      background: #ccc;
      cursor: pointer;
      outline: none;
      padding: 0;
      display: inline-flex;
      align-items: center;
      justify-content: center;
    }
    
    .window-controls .control.close {
      background: #ff5f57;
      border-color: #e0443e;
    }
    
    .window-controls .control.minimize {
      background: #febb2e;
      border-color: #dea123;
    }
    
    .window-controls .control.maximize {
      background: #28c840;
      border-color: #1aab2c;
    }
    
    .window-controls .control::after {
      content: '';
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      opacity: 0;
      transition: opacity 0.2s ease;
    }
    
    .card-header:hover .window-controls .control::after {
      opacity: 0.8;
    }
    
    .window-controls .control.close::after {
      content: 'Ã—';
      width: auto;
      height: auto;
      background: none;
      font-size: 10px;
      line-height: 1;
      font-weight: 700;
      color: rgba(0, 0, 0, 0.7);
    }
    
    .window-controls .control.minimize::after {
      width: 6px;
      height: 2px;
      background: rgba(0, 0, 0, 0.6);
    }
    
    .window-controls .control.maximize::after {
      width: 6px;
      height: 6px;
      background: linear-gradient(
        45deg,
        rgba(0, 0, 0, 0.6) 0%,
        rgba(0, 0, 0, 0.6) 45%,
        transparent 45%,
        transparent 55%,
        rgba(0, 0, 0, 0.6) 55%,
        rgba(0, 0, 0, 0.6) 100%
      );
    }
    
    .card-title {
      font-size: 13px;
      font-weight: 600;
      color: rgba(0, 0, 0, 0.55);
      padding-left: 10px;
      flex: 1;
    }
    
    .card-body {
      padding: 16px;
      font-size: 16px;
      line-height: 1.4;
      font-weight: 600;
      color: rgba(0, 0, 0, 0.72);
    }
    
    @media (max-width: 768px) {
      .header h1 {
        font-size: 2rem;
      }
      
      .header p {
        font-size: 1rem;
      }
      
      .floating-text {
        padding: 10px 18px;
        font-size: 0.9rem;
      }
      
      .go-button {
        padding: 14px 40px;
        font-size: 24px;
        top: 65%; /* åœ¨ç§»åŠ¨è®¾å¤‡ä¸Šç¨å¾®è°ƒæ•´ä½ç½® */
      }
      
      .card {
        width: 180px;
        border-radius: 10px;
      }
      
      .card-body {
        padding: 14px;
        font-size: 14px;
      }
      
      .card-title {
        font-size: 12px;
      }
      
      .music-control {
        top: 20px;
        right: 20px;
        width: 45px;
        height: 45px;
      }
      
      .music-loading {
        top: 20px;
        right: 75px;
        font-size: 11px;
        padding: 6px 10px;
      }
    }

     /* æé¾™å›¾ç‰‡åŠ¨æ€æ‚¬æµ® */
        .floating-image {
                position: fixed;
                bottom: 35px;
                left: 15px;
                width: 100px;
                height: auto;
                z-index: 1000;
                /* opacity: 0; */
                transition: opacity 0.3s ease-in-out;
        }
        /* .floating-image.visible {
                opacity: 1;
        } */
  </style>
</head>
<!-- ------------------------------------------------------------------------------------------------------------------ -->
<body>
    
  <!-- çˆ±å¿ƒåŠ¨ç”»å®¹å™¨ -->
  <div class="heart-container" id="heartContainer">
    <div class="dynamic-bg" id="dynamicBg"></div>
    <div class="particles" id="particles"></div>

    <img src="img/logo/5.gif" alt="åŠ è½½ä¸å‡ºæ¥" class="floating-image" title="ğŸ’•">
    
    <div class="header">
      <h1>ğŸ¥°å¿ƒåŠ¨æ—¶åˆ»-Blue</h1>
      <p>è®©æ–‡å­—å¦‚ç¹æ˜Ÿèˆ¬æ±‡èšæˆçˆ±
        <br>æ±Ÿæ²³ä¸å˜ï¼Œæ—¥æœˆæœ‰ä½ 
      </p>
    </div>
    
    <div class="floating-container" id="floatingContainer"></div>
    
    <button class="go-button" id="goButton">GO</button>
    
    <!-- éŸ³ä¹æ§åˆ¶æŒ‰é’® -->
    <div class="music-control playing" id="musicControl">
      <div class="icon">
        <div class="play-icon">
          <svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
            <path d="M8 5V19L19 12L8 5Z" fill="#ff9a9e"/>
          </svg>
        </div>
        <div class="pause-icon">
          <svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
            <path d="M6 4H10V20H6V4Z" fill="#ff9a9e"/>
            <path d="M14 4H18V20H14V4Z" fill="#ff9a9e"/>
          </svg>
        </div>
      </div>
      <div class="music-waves"></div>
    </div>
    
    <!-- éŸ³ä¹åŠ è½½æç¤º -->   
    <div class="music-loading" id="musicLoading">éŸ³ä¹åŠ è½½ä¸­...</div>
    
    <div class="footer">
      <pre>  Â© æµ·å…®æµ·å…®æµ©æ— å  éªé©¬å¥”å…®å¥‹å››è¹„ 
  ç¾äººç¾äººçœ¼å«å•µ æ›´æœ‰å•å”‡åŠ¨äººå¿ƒ & Blue  </pre>
    </div>
  </div>
  
  <!-- ä¾¿ç­¾å¢™å®¹å™¨ -->
  <div class="sticky-container" id="stickyContainer">
    <div id="board"></div>
  </div>

  <!-- éŸ³é¢‘å…ƒç´  -->
  <audio id="bgMusic" autoplay loop preload="auto">
    <source src="audio/åå¥³å­©.mp3" type="audio/mpeg">
    æ‚¨çš„æµè§ˆå™¨ä¸æ”¯æŒéŸ³é¢‘å…ƒç´ ã€‚
  </audio>

  <script>
    // çˆ±å¿ƒåŠ¨ç”»ç›¸å…³ä»£ç 
    const heartContainer = document.getElementById("heartContainer");
    const floatingContainer = document.getElementById("floatingContainer");
    const particlesContainer = document.getElementById("particles");
    const dynamicBg = document.getElementById("dynamicBg");
    const goButton = document.getElementById("goButton");
    const stickyContainer = document.getElementById("stickyContainer");
    const musicControl = document.getElementById("musicControl");
    const bgMusic = document.getElementById("bgMusic");
    const musicLoading = document.getElementById("musicLoading");
    
    // æ–‡å­—åˆ—è¡¨
    const texts = [
      "æ¯æ¬¡æƒ³ä½ æ˜Ÿæ˜Ÿéƒ½äº®äº†",
      "ä»Šå¤œçš„æ¢¦ç»™ä½ ",
      "ä½ çš„æ¸©æŸ”è®©æˆ‘æ²¦é™·",
      "æœ‰ä½ åœ¨ é£éƒ½ç”œç”œçš„",
      "æƒ³ç‰µä½ çš„æ‰‹çœ‹æ—¥è½",
      "ä¸–ç•Œå› ä½ è€Œç¾ä¸½",
      "ä¸€ç¬ä¹Ÿæ˜¯æ°¸æ’",
      "è¯·æŠ±ç´§æˆ‘ä¸€ç‚¹",
      "ä¸ºä½ å¿ƒåŠ¨ä¸æ­¢",
      "ä½ æ˜¯æˆ‘çš„å¿ƒåŠ¨å¼€å…³",
      "æƒ³å’Œä½ çœ‹æµ·",
      "ç”œåœ¨é£é‡Œä¹Ÿåœ¨å¿ƒé‡Œ",
      "çˆ±ä½ ä¸æ­¢ä¸‰åƒé",
      "ä½ æ˜¯æˆ‘çš„å®‡å®™",
      "å¿ƒè·³ä¸ºä½ åŠ é€Ÿ",
      "ä½™ç”Ÿè¯·å¤šæŒ‡æ•™",
      "çœ¼ä¸­åªæœ‰ä½ ",
      "æ¸©æŸ”è—åœ¨ç»†èŠ‚é‡Œ"
    ];

    // ä¼˜é›…æµ…è‰²æ¸å˜èƒŒæ™¯åˆ—è¡¨
    const gradients = [
      "linear-gradient(135deg, #a1c4fd, #c2e9fb)",
      "linear-gradient(135deg, #d4fc79, #96e6a1)",
      "linear-gradient(135deg, #fbc2eb, #a6c1ee)",
      "linear-gradient(135deg, #84fab0, #8fd3f4)",
      "linear-gradient(135deg, #fdcbf1, #e6dee9)",
      "linear-gradient(135deg, #a3bded, #6991c7)",
      "linear-gradient(135deg, #fad0c4, #ffd1ff)",
      "linear-gradient(135deg, #ff9a9e, #fecfef)",
      "linear-gradient(135deg, #f6d365, #fda085)",
      "linear-gradient(135deg, #e0c3fc, #8ec5fc)",
      "linear-gradient(135deg, #cd9cf2, #f6f3ff)",
      "linear-gradient(135deg, #a8edea, #fed6e3)"
    ];

    let isHeartFormed = false;
    let randomInterval;
    let heartElements = [];
    let animationId;
    let isMusicPlaying = true;
    let userInteracted = false;

    // åˆå§‹åŒ–èƒŒæ™¯ç²’å­
    function initParticles() {
      const particleCount = 40;
      
      for (let i = 0; i < particleCount; i++) {
        const particle = document.createElement("div");
        particle.className = "particle";
        
        // éšæœºä½ç½®
        const x = Math.random() * window.innerWidth;
        const y = Math.random() * window.innerHeight;
        particle.style.left = `${x}px`;
        particle.style.top = `${y}px`;
        
        // éšæœºå¤§å°
        const size = 2 + Math.random() * 3;
        particle.style.width = `${size}px`;
        particle.style.height = `${size}px`;
        
        // éšæœºé¢œè‰²
        const colors = ['rgba(255, 255, 255, 0.7)', 'rgba(200, 220, 255, 0.6)', 'rgba(255, 220, 240, 0.6)'];
        particle.style.background = colors[Math.floor(Math.random() * colors.length)];
        
        // éšæœºåŠ¨ç”»
        const duration = 15 + Math.random() * 20;
        const delay = Math.random() * 5;
        
        particle.style.animation = `float ${duration}s ${delay}s infinite ease-in-out`;
        
        particlesContainer.appendChild(particle);
      }
    }

    // åˆå§‹åŒ–åŠ¨æ€èƒŒæ™¯
    function initDynamicBackground() {
      const circleCount = 5;
      const colors = [
        'rgba(161, 196, 253, 0.3)',
        'rgba(212, 252, 121, 0.3)',
        'rgba(251, 194, 235, 0.3)',
        'rgba(132, 250, 176, 0.3)',
        'rgba(253, 203, 241, 0.3)'
      ];
      
      for (let i = 0; i < circleCount; i++) {
        const circle = document.createElement("div");
        circle.className = "bg-circle";
        
        // éšæœºä½ç½®
        const x = Math.random() * window.innerWidth;
        const y = Math.random() * window.innerHeight;
        circle.style.left = `${x}px`;
        circle.style.top = `${y}px`;
        
        // éšæœºå¤§å°
        const size = 100 + Math.random() * 300;
        circle.style.width = `${size}px`;
        circle.style.height = `${size}px`;
        
        // éšæœºé¢œè‰²
        circle.style.background = colors[Math.floor(Math.random() * colors.length)];
        
        // éšæœºåŠ¨ç”»å»¶è¿Ÿ
        const delay = Math.random() * 10;
        circle.style.animationDelay = `${delay}s`;
        
        dynamicBg.appendChild(circle);
      }
    }

    // ç”Ÿæˆçˆ±å¿ƒå½¢çŠ¶çš„ç‚¹ - ä¿®å¤å±…ä¸­é—®é¢˜
    function generateHeartPoints() {
      const points = [];
      const centerX = window.innerWidth / 2;
      const centerY = window.innerHeight / 2;
      const size = Math.min(window.innerWidth, window.innerHeight) * 0.25;
      
      // ä½¿ç”¨é€‚ä¸­çš„æ­¥é•¿ï¼Œä½¿çˆ±å¿ƒé€‚åº¦å¯†é›†
      for (let t = 0; t <= 2 * Math.PI; t += 0.08) {
        const x = 16 * Math.pow(Math.sin(t), 3);
        const y = -(13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t));
        
        points.push({
          x: centerX + x * size / 16,
          y: centerY + y * size / 16
        });
      }
      
      return points;
    }

    // åˆ›å»ºé—ªçƒæ•ˆæœ
    function createSparkle(x, y) {
      const sparkle = document.createElement("div");
      sparkle.className = "sparkle";
      sparkle.style.left = `${x}px`;
      sparkle.style.top = `${y}px`;
      floatingContainer.appendChild(sparkle);
      
      // éšæœºå¤§å°
      const size = 2 + Math.random() * 4;
      sparkle.style.width = `${size}px`;
      sparkle.style.height = `${size}px`;
      
      // éšæœºé¢œè‰²
      const colors = ['#ff9a9e', '#a1c4fd', '#d4fc79', '#fbc2eb', '#84fab0'];
      sparkle.style.background = colors[Math.floor(Math.random() * colors.length)];
      
      // é—ªçƒåŠ¨ç”»
      sparkle.animate([
        { opacity: 0, transform: 'scale(0) rotate(0deg)' },
        { opacity: 1, transform: 'scale(1.5) rotate(180deg)' },
        { opacity: 0, transform: 'scale(0) rotate(360deg)' }
      ], {
        duration: 1000 + Math.random() * 1000,
        easing: 'ease-out'
      });
      
      // ç§»é™¤å…ƒç´ 
      setTimeout(() => {
        if (sparkle.parentNode) {
          sparkle.remove();
        }
      }, 2000);
    }

    function createFloatingText() {
      if (isHeartFormed) return;
      
      const textEl = document.createElement("div");
      textEl.className = "floating-text";
      
      // éšæœºæ–‡å­—å†…å®¹
      textEl.textContent = texts[Math.floor(Math.random() * texts.length)];
      
      // ä»å„ä¸ªæ–¹å‘ç”Ÿæˆï¼šä¸Šä¸‹å·¦å³éšæœºä½ç½®
      const direction = Math.floor(Math.random() * 4); // 0:ä¸Š, 1:å³, 2:ä¸‹, 3:å·¦
      let x, y;
      const offset = 80; // è¶…å‡ºå±å¹•çš„è·ç¦»
      
      switch(direction) {
        case 0: // ä¸Šè¾¹
          x = Math.random() * window.innerWidth;
          y = -offset;
          break;
        case 1: // å³è¾¹
          x = window.innerWidth + offset;
          y = Math.random() * window.innerHeight;
          break;
        case 2: // ä¸‹è¾¹
          x = Math.random() * window.innerWidth;
          y = window.innerHeight + offset;
          break;
        case 3: // å·¦è¾¹
          x = -offset;
          y = Math.random() * window.innerHeight;
          break;
      }
      
      textEl.style.left = `${x}px`;
      textEl.style.top = `${y}px`;
      
      // éšæœºå­—ä½“å¤§å°
      const fontSize = 14 + Math.random() * 4;
      textEl.style.fontSize = `${fontSize}px`;
      
      // éšæœºæµ…è‰²æ¸å˜èƒŒæ™¯ï¼Œå¶å°”ä½¿ç”¨ç‰¹æ®Šæ•ˆæœ
      const useSpecial = Math.random() > 0.85;
      if (useSpecial) {
        textEl.classList.add('special-text');
      } else {
        textEl.style.background = gradients[Math.floor(Math.random() * gradients.length)];
      }
      
      // éšæœºåŠ¨ç”»æ—¶é•¿
      const duration = 5 + Math.random() * 3;
      textEl.style.animationDuration = `${duration}s`;
      
      floatingContainer.appendChild(textEl);
      
      // åˆ›å»ºé—ªçƒæ•ˆæœ
      setTimeout(() => {
        createSparkle(x, y);
      }, 100);
      
      // åŠ¨ç”»ç»“æŸåç§»é™¤å…ƒç´ 
      setTimeout(() => {
        if (textEl.parentNode) {
          textEl.remove();
        }
      }, duration * 1000);
    }

    function createHeartText(point, index) {
      const textEl = document.createElement("div");
      textEl.className = "floating-text heart-text";
      
      // éšæœºæ–‡å­—å†…å®¹
      textEl.textContent = texts[Math.floor(Math.random() * texts.length)];
      
      // ä»å±å¹•è¾¹ç¼˜éšæœºä½ç½®å¼€å§‹
      const direction = Math.floor(Math.random() * 4);
      let startX, startY;
      const offset = 100;
      
      switch(direction) {
        case 0: // ä¸Šè¾¹
          startX = Math.random() * window.innerWidth;
          startY = -offset;
          break;
        case 1: // å³è¾¹
          startX = window.innerWidth + offset;
          startY = Math.random() * window.innerHeight;
          break;
        case 2: // ä¸‹è¾¹
          startX = Math.random() * window.innerWidth;
          startY = window.innerHeight + offset;
          break;
        case 3: // å·¦è¾¹
          startX = -offset;
          startY = Math.random() * window.innerHeight;
          break;
      }
      
      textEl.style.left = `${startX}px`;
      textEl.style.top = `${startY}px`;
      
      // éšæœºå­—ä½“å¤§å°
      const fontSize = 14 + Math.random() * 4;
      textEl.style.fontSize = `${fontSize}px`;
      
      // éšæœºæµ…è‰²æ¸å˜èƒŒæ™¯
      textEl.style.background = gradients[Math.floor(Math.random() * gradients.length)];
      
      floatingContainer.appendChild(textEl);
      
      // ä½¿ç”¨åŠ¨ç”»ç§»åŠ¨åˆ°çˆ±å¿ƒä½ç½® - ä¿®å¤å…ƒç´ å±…ä¸­é—®é¢˜
      setTimeout(() => {
        // è·å–å…ƒç´ çš„å®é™…å°ºå¯¸
        const rect = textEl.getBoundingClientRect();
        const centerX = point.x - rect.width / 2;
        const centerY = point.y - rect.height / 2;
        
        textEl.style.transition = `all 3s cubic-bezier(0.2, 0.8, 0.3, 1) ${index * 0.15}s`;
        textEl.style.left = `${centerX}px`;
        textEl.style.top = `${centerY}px`;
        
        // æ·»åŠ è½»å¾®è„‰åŠ¨æ•ˆæœ
        setTimeout(() => {
          textEl.classList.add('pulse');
        }, 3000 + index * 150);
      }, 100);
      
      heartElements.push(textEl);
    }

    function startHeartAnimation() {
      const heartPoints = generateHeartPoints();
      const pointsCount = heartPoints.length;
      
      // é€‰æ‹©éƒ¨åˆ†ç‚¹å½¢æˆç©ºå¿ƒçˆ±å¿ƒ - é€‚åº¦å¯†é›†
      const selectedPoints = [];
      for (let i = 0; i < pointsCount; i += 2) {
        selectedPoints.push(heartPoints[i]);
      }
      
      // æŒ‰é¡ºåºåˆ›å»ºçˆ±å¿ƒå…ƒç´  - é€‚ä¸­çš„å‡ºç°é€Ÿåº¦
      selectedPoints.forEach((point, index) => {
        setTimeout(() => {
          createHeartText(point, index);
          createSparkle(point.x, point.y);
        }, index * 200);
      });
      
      // å½“çˆ±å¿ƒå®Œæˆåæ˜¾ç¤ºGOæŒ‰é’®
      setTimeout(() => {
        isHeartFormed = true;
        clearInterval(randomInterval);
        cancelAnimationFrame(animationId);
        
        // æ˜¾ç¤ºGOæŒ‰é’®
        setTimeout(() => {
          goButton.classList.add('show');
        }, 500);
      }, selectedPoints.length * 200 + 3000);
    }

    // çˆ±å¿ƒæ•£å¼€åŠ¨ç”»
    function scatterHeart() {
      // ä¸ºæ¯ä¸ªçˆ±å¿ƒå…ƒç´ è®¾ç½®éšæœºæ•£å¼€æ–¹å‘
      heartElements.forEach((heartEl, index) => {
        const angle = Math.random() * Math.PI * 2;
        const distance = 1000 + Math.random() * 500;
        const targetX = heartEl.offsetLeft + Math.cos(angle) * distance;
        const targetY = heartEl.offsetTop + Math.sin(angle) * distance;
        
        // è®¾ç½®æ•£å¼€åŠ¨ç”»
        setTimeout(() => {
          heartEl.style.transition = `all 2s cubic-bezier(0.4, 0, 0.2, 1) ${index * 0.05}s`;
          heartEl.style.left = `${targetX}px`;
          heartEl.style.top = `${targetY}px`;
          heartEl.style.opacity = '0';
        }, index * 50);
      });
      
      // åŠ¨ç”»å®Œæˆååˆ‡æ¢åˆ°ä¾¿ç­¾å¢™
      setTimeout(() => {
        // éšè—çˆ±å¿ƒåŠ¨ç”»å®¹å™¨
        heartContainer.style.opacity = '0';
        
        // æ˜¾ç¤ºä¾¿ç­¾å¢™å®¹å™¨
        setTimeout(() => {
          stickyContainer.style.opacity = '1';
          startStickyWall();
        }, 1000);
      }, 2000);
    }

    // éŸ³ä¹æ§åˆ¶åŠŸèƒ½
    function toggleMusic() {
      if (!userInteracted) {
        userInteracted = true;
        // å°è¯•æ’­æ”¾éŸ³ä¹
        playMusic();
        return;
      }
      
      if (isMusicPlaying) {
        bgMusic.pause();
        musicControl.classList.remove('playing');
        musicControl.classList.add('paused');
      } else {
        playMusic();
      }
      isMusicPlaying = !isMusicPlaying;
    }

    // æ’­æ”¾éŸ³ä¹
    function playMusic() {
      bgMusic.play().then(() => {
        musicControl.classList.add('playing');
        musicControl.classList.remove('paused');
        isMusicPlaying = true;
        musicLoading.classList.remove('show');
      }).catch(e => {
        console.log('æ’­æ”¾éŸ³ä¹å¤±è´¥:', e);
        musicControl.classList.remove('playing');
        musicControl.classList.add('paused');
        isMusicPlaying = false;
        musicLoading.textContent = 'ç‚¹å‡»æ’­æ”¾éŸ³ä¹';
        musicLoading.classList.add('show');
      });
    }

    // ä¾¿ç­¾å¢™ç›¸å…³ä»£ç 
    const board = document.getElementById('board')
    const messages = [
      'ä¿æŒå¥½å¿ƒæƒ…',
      'å¤šå–æ°´å“¦',
      'ä»Šå¤©è¾›è‹¦å•¦',
      'æ—©ç‚¹ä¼‘æ¯',
      'è®°å¾—åƒæ°´æœ',
      'åŠ æ²¹ï¼Œä½ å¯ä»¥çš„',
      'ç¥ä½ é¡ºåˆ©',
      'ä¿æŒå¾®ç¬‘å‘€',
      'æ„¿æ‰€æœ‰çƒ¦æ¼éƒ½æ¶ˆå¤±',
      'æœŸå¾…ä¸‹ä¸€æ¬¡è§é¢',
      'æ¢¦æƒ³æ€»ä¼šå®ç°',
      'å¤©æ°”å†·äº†ï¼Œå¤šç©¿è¡£æœ',
      'è®°å¾—ç»™è‡ªå·±æ”¾æ¾',
      'æ¯å¤©éƒ½è¦å…ƒæ°”æ»¡æ»¡',
      'ä»Šå¤©ä¹Ÿè¦å¥½å¥½çˆ±è‡ªå·±',
      'é€‚å½“ä¼‘æ¯ä¸€ä¸‹',
      "æ¯æ¬¡æƒ³ä½ æ˜Ÿæ˜Ÿéƒ½äº®äº†",
      "ä»Šå¤œçš„æ¢¦ç»™ä½ ",
      "ä½ çš„æ¸©æŸ”è®©æˆ‘æ²¦é™·",
      "æœ‰ä½ åœ¨ é£éƒ½ç”œç”œçš„",
      "æƒ³ç‰µä½ çš„æ‰‹çœ‹æ—¥è½",
      "ä¸–ç•Œå› ä½ è€Œè½¯ç¾ä¸½",
      "ä¸€ç¬ä¹Ÿæ˜¯æ°¸æ’",
      "è¯·æŠ±ç´§æˆ‘ä¸€ç‚¹",
      "ä¸ºä½ å¿ƒåŠ¨ä¸æ­¢",
      "ä½ æ˜¯æˆ‘çš„å¿ƒåŠ¨å¼€å…³",
      "æƒ³å’Œä½ çœ‹æµ·",
      "ç”œåœ¨é£é‡Œä¹Ÿåœ¨å¿ƒé‡Œ",
      "çˆ±ä½ ä¸æ­¢ä¸‰åƒé",
      "ä½ æ˜¯æˆ‘çš„å®‡å®™",
      "å¿ƒè·³ä¸ºä½ åŠ é€Ÿ",
      "ä½™ç”Ÿè¯·å¤šæŒ‡æ•™",
      "çœ¼ä¸­åªæœ‰ä½ ",
      "æ¸©æŸ”è—åœ¨ç»†èŠ‚é‡Œ"
    ]

    const colors = [
      '#ffe0e3',
      '#c7f0ff',
      '#ffd8a8',
      '#d9f2d9',
      '#e5d7ff',
      '#f9f7d9',
      '#d2f0f8',
      '#ffd4f5'
    ]

    const cardStates = new WeakMap()
    const MAXIMIZED_LAYER = 1000000
    let activeMaximizedCard = null
    let isMobile =
      window.matchMedia('(pointer: coarse)').matches ||
      window.innerWidth <= 768
    const maxCards = isMobile ? 120 : 180
    const initialCardCount = isMobile ? 18 : 30
    const spawnInterval = isMobile ? 700 : 400
    let zIndexCursor = 200

    function randomFrom(array) {
      return array[Math.floor(Math.random() * array.length)]
    }

    function clamp(value, min, max) {
      return Math.min(Math.max(value, min), max)
    }

    function applyTransform(card, state) {
      const scale = state.scale ?? 1
      const translateX = state.translateX ?? 0
      const translateY = state.translateY ?? 0
      const angle = state.angle ?? 0
      card.style.transform = `translate(${translateX}px, ${translateY}px) scale(${scale}) rotate(${angle}deg)`
    }

    function bringToFront(card) {
      if (card === activeMaximizedCard) {
        card.style.zIndex = MAXIMIZED_LAYER
        return
      }

      zIndexCursor += 1
      if (activeMaximizedCard && zIndexCursor >= MAXIMIZED_LAYER) {
        zIndexCursor = MAXIMIZED_LAYER - 1
      }

      card.style.zIndex = zIndexCursor
    }

    function setupCardInteractions(card) {
      const header = card.querySelector('.card-header')
      const closeBtn = card.querySelector('.control.close')
      const minimizeBtn = card.querySelector('.control.minimize')
      const maximizeBtn = card.querySelector('.control.maximize')

      closeBtn.addEventListener('click', event => {
        event.stopPropagation()
        closeCard(card)
      })

      minimizeBtn.addEventListener('click', event => {
        event.stopPropagation()
        minimizeCard(card)
      })

      maximizeBtn.addEventListener('click', event => {
        event.stopPropagation()
        toggleMaximize(card)
      })

      header.addEventListener('pointerdown', event => {
        if (event.pointerType === 'touch') return
        startDrag(event, card)
      })

      card.addEventListener('pointerdown', () => {
        bringToFront(card)
      })

      header.addEventListener('dblclick', event => {
        if (!event.target.closest('.control')) {
          toggleMaximize(card)
        }
      })
    }

    function closeCard(card) {
      const state = cardStates.get(card)
      if (!state || state.closing) return
      if (card === activeMaximizedCard) {
        activeMaximizedCard = null
      }
      state.closing = true
      state.scale = 0.1
      card.style.opacity = '0'
      applyTransform(card, state)

      const handleTransitionEnd = event => {
        if (event.propertyName === 'opacity') {
          card.removeEventListener('transitionend', handleTransitionEnd)
          card.remove()
        }
      }

      card.addEventListener('transitionend', handleTransitionEnd)
    }

    function minimizeCard(card) {
      const state = cardStates.get(card)
      if (!state || state.closing) return

      const runMinimize = () => {
        state.closing = true
        bringToFront(card)
        const bottom = Math.max(window.innerHeight - 24, 0)
        const targetLeft = clamp(
          state.left,
          16,
          Math.max(window.innerWidth - card.offsetWidth - 16, 16)
        )

        state.left = targetLeft
        state.top = bottom
        state.scale = 0.1
        state.angle = 0
        card.style.left = `${targetLeft}px`
        card.style.top = `${bottom}px`
        card.style.opacity = '0.35'
        applyTransform(card, state)

        const handleTransitionEnd = event => {
          if (event.propertyName === 'transform') {
            card.removeEventListener('transitionend', handleTransitionEnd)
            card.remove()
          }
        }

        card.addEventListener('transitionend', handleTransitionEnd)
      }

      if (state.maximized) {
        activeMaximizedCard = null
        state.maximized = false
        card.classList.remove('maximized')
        card.style.borderRadius = '12px'
        state.left = 0
        state.top = 0
        state.scale = 1
        state.angle = 0
        applyTransform(card, state)

        requestAnimationFrame(() => {
          requestAnimationFrame(runMinimize)
        })
        return
      }

      runMinimize()
    }

    function toggleMaximize(card) {
      const state = cardStates.get(card)
      if (!state || state.closing) return

      if (state.maximized) {
        restoreFromMaximize(card, state)
      } else {
        maximizeCard(card, state)
      }
    }

    function maximizeCard(card, state) {
      state.beforeMaximize = {
        left: state.left,
        top: state.top,
        scale: state.scale ?? 1,
        width: card.offsetWidth,
        height: card.offsetHeight,
        angle: state.angle ?? 0
      }

      card.classList.add('maximized')
      card.style.left = '0px'
      card.style.top = '0px'
      card.style.width = `${window.innerWidth}px`
      card.style.height = `${window.innerHeight}px`
      card.style.borderRadius = '0'

      state.left = 0
      state.top = 0
      state.scale = 1
      state.angle = 0
      applyTransform(card, state)
      activeMaximizedCard = card
      bringToFront(card)
      state.maximized = true
    }

    function restoreFromMaximize(card, state) {
      const previous = state.beforeMaximize
      if (!previous) return

      card.classList.remove('maximized')
      card.style.left = `${previous.left}px`
      card.style.top = `${previous.top}px`
      card.style.width = `${previous.width}px`
      card.style.height = `${previous.height}px`
      card.style.borderRadius = '12px'

      state.left = previous.left
      state.top = previous.top
      state.scale = previous.scale ?? 1
      state.angle = previous.angle ?? state.angle ?? 0
      applyTransform(card, state)
      state.maximized = false
      if (activeMaximizedCard === card) {
        activeMaximizedCard = null
      }
      bringToFront(card)
      state.lastPosition = { left: state.left, top: state.top }

      setTimeout(() => {
        if (!state.maximized) {
          card.style.width = ''
          card.style.height = ''
          state.width = card.offsetWidth
          state.height = card.offsetHeight
        }
      }, 360)
    }

    function startDrag(event, card) {
      const control = event.target.closest('.control')
      if (control) return

      const state = cardStates.get(card)
      if (!state || state.closing || state.maximized) return

      event.preventDefault()
      bringToFront(card)

      const header = card.querySelector('.card-header')
      card.classList.add('dragging')
      header.classList.add('dragging')

      state.dragging = true
      state.dragOffsetX = event.clientX - state.left
      state.dragOffsetY = event.clientY - state.top

      let dragFrame = null
      let pendingLeft = state.left
      let pendingTop = state.top

      const commitDrag = () => {
        dragFrame = null
        const maxLeft = Math.max(window.innerWidth - card.offsetWidth, 0)
        const maxTop = Math.max(window.innerHeight - card.offsetHeight, 0)
        state.left = clamp(pendingLeft, -card.offsetWidth * 0.4, maxLeft)
        state.top = clamp(pendingTop, -card.offsetHeight * 0.4, maxTop)
        card.style.left = `${state.left}px`
        card.style.top = `${state.top}px`
      }

      const handlePointerMove = moveEvent => {
        if (!state.dragging) return

        pendingLeft = moveEvent.clientX - state.dragOffsetX
        pendingTop = moveEvent.clientY - state.dragOffsetY
        if (dragFrame === null) {
          dragFrame = requestAnimationFrame(commitDrag)
        }
      }

      const handlePointerUp = () => {
        state.dragging = false
        state.lastPosition = { left: state.left, top: state.top }
        card.classList.remove('dragging')
        header.classList.remove('dragging')
        if (dragFrame !== null) {
          cancelAnimationFrame(dragFrame)
          commitDrag()
        }
        document.removeEventListener('pointermove', handlePointerMove)
        document.removeEventListener('pointerup', handlePointerUp)
      }

      document.addEventListener('pointermove', handlePointerMove)
      document.addEventListener('pointerup', handlePointerUp)
    }

    function createCard() {
      const card = document.createElement('div')
      card.className = 'card'

      const color = randomFrom(colors)
      const angleRange = isMobile ? 6 : 10
      const angle = (Math.random() - 0.5) * angleRange
      const cardWidth = isMobile ? 180 : 220
      const cardHeight = isMobile ? 130 : 140
      const horizontalMargin = isMobile ? 12 : 16
      const verticalMargin = isMobile ? 12 : 20
      const left =
        horizontalMargin +
        Math.random() *
          Math.max(window.innerWidth - cardWidth - horizontalMargin * 2, 0)
      const top =
        verticalMargin +
        Math.random() *
          Math.max(window.innerHeight - cardHeight - verticalMargin * 2, 0)

      card.style.background = color
      card.style.left = `${left}px`
      card.style.top = `${top}px`
      if (activeMaximizedCard && zIndexCursor >= MAXIMIZED_LAYER - 2) {
        zIndexCursor = MAXIMIZED_LAYER - 2
      }
      card.style.zIndex = ++zIndexCursor

      card.innerHTML = `
        <div class="card-header">
          <div class="window-controls">
            <button class="control close" type="button" aria-label="å…³é—­"></button>
            <button class="control minimize" type="button" aria-label="æœ€å°åŒ–"></button>
            <button class="control maximize" type="button" aria-label="æœ€å¤§åŒ–"></button>
          </div>
          <div class="card-title">æ¸©é¦¨æç¤º</div>
        </div>
        <div class="card-body">${randomFrom(messages)}</div>
      `

      const state = {
        angle,
        scale: isMobile ? 0.85 : 0.7,
        translateX: 0,
        translateY: 0,
        left,
        top,
        maximized: false,
        closing: false,
        lastPosition: { left, top }
      }

      cardStates.set(card, state)
      applyTransform(card, state)
      board.appendChild(card)

      state.width = card.offsetWidth
      state.height = card.offsetHeight

      requestAnimationFrame(() => {
        state.scale = 1
        applyTransform(card, state)
        card.style.opacity = '1'
      })

      setupCardInteractions(card)

      if (board.children.length > maxCards) {
        const oldest = board.firstElementChild
        if (oldest && oldest !== card) {
          oldest.remove()
        }
      }
    }

    function startStickyWall() {
      document.body.classList.toggle('is-mobile', isMobile);

      for (let i = 0; i < initialCardCount; i++) {
        setTimeout(createCard, i * (isMobile ? 60 : 40));
      }

      setInterval(() => {
        createCard();
      }, spawnInterval);

      window.addEventListener('resize', () => {
        isMobile =
          window.matchMedia('(pointer: coarse)').matches ||
          window.innerWidth <= 768;
        document.body.classList.toggle('is-mobile', isMobile);

        document.querySelectorAll('.card.maximized').forEach(card => {
          card.style.width = `${window.innerWidth}px`;
          card.style.height = `${window.innerHeight}px`;
        });
      });
    }

    // åˆå§‹åŒ–çˆ±å¿ƒåŠ¨ç”»
    initParticles();
    initDynamicBackground();

    // åˆå§‹åˆ›å»ºæ›´å¤šå…ƒç´ 
    for (let i = 0; i < 30; i++) {
      setTimeout(createFloatingText, i * 200);
    }

    // æŒç»­ç”Ÿæˆæ›´å¤šæ–°å…ƒç´  - å¢åŠ é¢‘ç‡
    randomInterval = setInterval(createFloatingText, 400);

    // å»¶è¿Ÿåå¼€å§‹çˆ±å¿ƒåŠ¨ç”»
    setTimeout(startHeartAnimation, 8000);

    // GOæŒ‰é’®ç‚¹å‡»äº‹ä»¶
    goButton.addEventListener('click', scatterHeart);

    // éŸ³ä¹æ§åˆ¶æŒ‰é’®ç‚¹å‡»äº‹ä»¶
    musicControl.addEventListener('click', toggleMusic);

    // é¡µé¢ç‚¹å‡»äº‹ä»¶ - ç”¨äºè§¦å‘éŸ³é¢‘æ’­æ”¾
    document.addEventListener('click', function() {
      if (!userInteracted) {
        userInteracted = true;
        // ç”¨æˆ·é¦–æ¬¡ç‚¹å‡»åå°è¯•æ’­æ”¾éŸ³ä¹
        playMusic();
      }
    });

    // éŸ³ä¹åŠ è½½äº‹ä»¶
    bgMusic.addEventListener('loadstart', function() {
      musicLoading.classList.add('show');
    });
    
    bgMusic.addEventListener('canplaythrough', function() {
      musicLoading.classList.remove('show');
    });
    
    bgMusic.addEventListener('error', function() {
      musicLoading.textContent = 'éŸ³ä¹åŠ è½½å¤±è´¥';
      musicLoading.classList.add('show');
      musicControl.classList.remove('playing');
      musicControl.classList.add('paused');
    });

    // å°è¯•è‡ªåŠ¨æ’­æ”¾éŸ³ä¹
    window.addEventListener('load', function() {
      // è®¾ç½®éŸ³é‡
      bgMusic.volume = 0.6;
      
      // å»¶è¿Ÿä¸€ä¸‹å†å°è¯•æ’­æ”¾ï¼Œç¡®ä¿é¡µé¢å·²åŠ è½½
      setTimeout(() => {
        playMusic();
      }, 1000);
    });

    // çª—å£è‡ªé€‚åº”
    window.addEventListener("resize", () => {
      floatingContainer.style.width = window.innerWidth + "px";
      floatingContainer.style.height = window.innerHeight + "px";
    });

    // ä½¿ç”¨requestAnimationFrameä¼˜åŒ–æ€§èƒ½
    function animate() {
      animationId = requestAnimationFrame(animate);
    }
    animate();
  </script>
</body>
</html>